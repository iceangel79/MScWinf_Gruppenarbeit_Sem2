{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# =====================================\n",
    "# Schritt 0: Setup & Bibliotheken\n",
    "# =====================================\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.metrics import classification_report\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "\n",
    "# Optional: Anzeigen von mehreren Outputs pro Zelle\n",
    "from IPython.core.interactiveshell import InteractiveShell\n",
    "InteractiveShell.ast_node_interactivity = \"all\"\n",
    "\n",
    "%matplotlib inline\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# =====================================\n",
    "# Schritt 1: Daten laden & erste Sichtung\n",
    "# =====================================\n",
    "\n",
    "# Pfad zu PÃ¤ckli 1\n",
    "base_path_p1 = \"C:/Users/Kay/OneDrive/Dokumente/Kay/School-Work/MsC Wirtschaftsinformatik/FS25/BINA/Semesterarbeit/Datensets fÃ¼r Semesterarbeit/archive (3)/\"\n",
    "\n",
    "# Lade die DatensÃ¤tze aus PÃ¤ckli 1\n",
    "df_meals = pd.read_csv(base_path_p1 + \"detailed_meals_macros_CLEANED.csv\")\n",
    "df_nutrition = pd.read_csv(base_path_p1 + \"Food_and_Nutrition__.csv\")\n",
    "\n",
    "# Pfad zu PÃ¤ckli 2\n",
    "base_path_p2 = \"C:/Users/Kay/OneDrive/Dokumente/Kay/School-Work/MsC Wirtschaftsinformatik/FS25/BINA/Semesterarbeit/Datensets fÃ¼r Semesterarbeit/archive (4)/FINAL FOOD DATASET/\"\n",
    "\n",
    "# Lade alle Group-Dateien einzeln (du kannst spÃ¤ter auch mergen)\n",
    "group1 = pd.read_csv(base_path_p2 + \"FOOD-DATA-GROUP1.csv\")\n",
    "group2 = pd.read_csv(base_path_p2 + \"FOOD-DATA-GROUP2.csv\")\n",
    "group3 = pd.read_csv(base_path_p2 + \"FOOD-DATA-GROUP3.csv\")\n",
    "group4 = pd.read_csv(base_path_p2 + \"FOOD-DATA-GROUP4.csv\")\n",
    "group5 = pd.read_csv(base_path_p2 + \"FOOD-DATA-GROUP5.csv\")\n",
    "\n",
    "# Oder direkt zusammenfÃ¼hren:\n",
    "food_groups_combined = pd.concat([group1, group2, group3, group4, group5], ignore_index=True)\n",
    "\n",
    "# Vorschau\n",
    "food_groups_combined.head()\n",
    "\n",
    "# BLV NÃ¤hrwerte: https://www.blv.admin.ch/blv/de/home/lebensmittel-und-ernaehrung/ernaehrung/empfehlungen-informationen/naehrstoffe/naehrstoffzufuhr-dynamische-tabelle.html\n",
    "excel_path = r\"C:/Users/Kay/OneDrive/Dokumente/Kay/School-Work/MsC Wirtschaftsinformatik/FS25/BINA/Semesterarbeit/Datensets fÃ¼r Semesterarbeit/Nutrient_requirements_CH - 2022.xlsx\"\n",
    "df_blv = pd.read_excel(excel_path)\n",
    "\n",
    "# Vorschau\n",
    "df_meals.info()\n",
    "df_meals.head()\n",
    "df_blv.head()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#  In diesem Schritt bereinigen wir die df_meals-Tabelle:\n",
    "\n",
    "# Leere Zellen prÃ¼fen, Doppelte EintrÃ¤ge entfernen, Datentypen prÃ¼fen\n",
    "df_meals.isnull().sum()\n",
    "df_meals.drop_duplicates(subset=[col for col in df_meals.columns if col != \"Disease_List\"], inplace=True)\n",
    "df_meals.dtypes\n",
    "\n",
    "# Disease-Spalte vorbereiten fÃ¼r Analyse\n",
    "df_meals[\"Disease_List\"] = df_meals[\"Disease\"].fillna(\"\").apply(lambda x: [d.strip() for d in x.split(\",\") if d.strip() != \"\"])\n",
    "\n",
    "# Neu: ZÃ¤hle Krankheiten je Person (0 bis n Krankheiten)\n",
    "df_meals[\"Disease_Count\"] = df_meals[\"Disease_List\"].apply(len)\n",
    "\n",
    "# Optional: Disease als Tuple zur Gruppierung (nur wenn .groupby() oder .value_counts() verwendet werden soll)\n",
    "df_meals[\"Disease_Tuple\"] = df_meals[\"Disease_List\"].apply(lambda x: tuple(x))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# =====================================\n",
    "# Validierung: DatenqualitÃ¤t & IntegritÃ¤t\n",
    "# =====================================\n",
    "\n",
    "# ðŸ“‹ Diese Zelle Ã¼berprÃ¼ft automatisch zentrale QualitÃ¤tsaspekte:\n",
    "# - Gibt es noch leere Zellen?\n",
    "# - EnthÃ¤lt jede Spalte den erwarteten Datentyp?\n",
    "# - Stimmen Anzahl Zeilen mit anderen Tabellen Ã¼berein?\n",
    "\n",
    "# Fehlende Werte checken\n",
    "missing = df_meals.isnull().sum()\n",
    "print(\"\\n# Fehlende Werte pro Spalte:\")\n",
    "print(missing[missing > 0])\n",
    "\n",
    "# Erwartete Datentypen\n",
    "expected_types = {\n",
    "    \"Ages\": np.int64,\n",
    "    \"Gender\": object,\n",
    "    \"Calories\": np.int64,\n",
    "    \"Disease_List\": list,\n",
    "    \"Disease_Tuple\": tuple,\n",
    "    \"Disease_Count\": np.int64\n",
    "}\n",
    "\n",
    "# Vergleich Ist vs. Erwartet\n",
    "print(\"\\n# Typvalidierung:\")\n",
    "for col, expected_type in expected_types.items():\n",
    "    actual_type = df_meals[col].iloc[0].__class__\n",
    "    if actual_type != expected_type:\n",
    "        print(f\"Typabweichung in '{col}': erwartet {expected_type}, ist {actual_type}\")\n",
    "\n",
    "# Anzahl Zeilen prÃ¼fen\n",
    "print(\"\\n# Anzahl DatensÃ¤tze:\", len(df_meals))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Zeige ALLE Zeilen mit fehlenden Werten in 'Breakfast Carbohydrates'\n",
    "fehlende = df_meals[df_meals[\"Breakfast Carbohydrates\"].isnull()]\n",
    "pd.set_option('display.max_columns', None)  # zeigt ALLE Spalten an\n",
    "display(fehlende)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Entfernen der Zeilen mit fehlenden Werten in 'Breakfast Carbohydrates'\n",
    "df_meals = df_meals.dropna(subset=[\"Breakfast Carbohydrates\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# =====================================\n",
    "# Schritt 3: Zuckerkonsum vs. Krankheit â€“ Vergleich\n",
    "# =====================================\n",
    "\n",
    "# Ziel: Vergleich des durchschnittlichen Zuckerkonsums bei Personen mit und ohne spezifische Krankheiten\n",
    "# DafÃ¼r wird fÃ¼r jede dokumentierte Krankheit der mittlere Zuckerkonsum verglichen (Krankheit vs. keine Krankheit)\n",
    "\n",
    "# Erstelle leere Listen fÃ¼r die Visualisierung\n",
    "krankheiten = []\n",
    "zucker_mit = []\n",
    "zucker_ohne = []\n",
    "\n",
    "# Iteriere Ã¼ber alle Krankheiten (einzeln aus der Disease-Spalte extrahiert)\n",
    "alle_krankheiten = df_meals[\"Disease_List\"].explode().dropna().unique()\n",
    "\n",
    "for krankheit in alle_krankheiten:\n",
    "    hat_krankheit = df_meals[\"Disease_List\"].apply(lambda x: krankheit in x)\n",
    "    ohne_krankheit = ~hat_krankheit\n",
    "\n",
    "    if hat_krankheit.sum() > 20 and ohne_krankheit.sum() > 20:\n",
    "        krankheiten.append(krankheit)\n",
    "        zucker_mit.append(df_meals.loc[hat_krankheit, \"Sugar\"].mean())\n",
    "        zucker_ohne.append(df_meals.loc[ohne_krankheit, \"Sugar\"].mean())\n",
    "\n",
    "# Visualisierung IBCS-konform (nebeneinander, sortiert)\n",
    "fig, ax = plt.subplots(figsize=(10, 5))\n",
    "bar_width = 0.4\n",
    "x = np.arange(len(krankheiten))\n",
    "\n",
    "ax.bar(x - bar_width/2, zucker_mit, width=bar_width, label=\"Personen mit Krankheit\", color=\"#4E79A7\")\n",
    "ax.bar(x + bar_width/2, zucker_ohne, width=bar_width, label=\"Personen ohne Krankheit\", color=\"#F28E2B\")\n",
    "\n",
    "\n",
    "ax.set_xticks(x)\n",
    "ax.set_xticklabels(krankheiten, rotation=45, ha=\"right\")\n",
    "ax.set_ylabel(\"Ã˜ Zuckerkonsum (g pro Tag)\")\n",
    "ax.set_xlabel(\"Krankheit\")\n",
    "ax.set_title(\"Zuckerkonsum pro Krankheit: mit vs. ohne Krankheit\")\n",
    "ax.legend()\n",
    "ax.grid(axis='y', linestyle='--', alpha=0.5)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# SAY-Prinzip (Interpretation)\n",
    "print(\"Klarer, differenzierter Vergleich: Bei einzelnen Krankheiten wie Diabetes oder Acne ist der Zuckerkonsum deutlich geringer, bei anderen (z.â€¯B. Weight Gain) leicht erhÃ¶ht.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ==============================\n",
    "# Zuckerkonsum â€“ Differenz mit vs. ohne Krankheit\n",
    "# ==============================\n",
    "\n",
    "# Listen fÃ¼r Krankheiten und Differenz\n",
    "krankheiten = []\n",
    "differenz_values = []\n",
    "\n",
    "\n",
    "alle_krankheiten = df_meals[\"Disease_List\"].explode().dropna().unique()\n",
    "\n",
    "for krankheit in alle_krankheiten:\n",
    "    hat_krankheit = df_meals[\"Disease_List\"].apply(lambda x: krankheit in x)\n",
    "    ohne_krankheit = ~hat_krankheit\n",
    "\n",
    "    if hat_krankheit.sum() > 20 and ohne_krankheit.sum() > 20:\n",
    "        zucker_mit = df_meals.loc[hat_krankheit, \"Sugar\"].mean()\n",
    "        zucker_ohne = df_meals.loc[ohne_krankheit, \"Sugar\"].mean()\n",
    "        krankheiten.append(krankheit)\n",
    "        differenz_values.append(zucker_mit - zucker_ohne)\n",
    "\n",
    "# Sort indices based on the difference values\n",
    "sorted_indices = np.argsort(differenz_values)\n",
    "\n",
    "# Sort the lists and arrays using the sorted indices\n",
    "krankheiten = [krankheiten[i] for i in sorted_indices]\n",
    "differenzen = [differenz_values[i] for i in sorted_indices]\n",
    "krankheiten = np.array(krankheiten)\n",
    "differenzen = np.array(differenzen)\n",
    "\n",
    "# Visualisierung: Differenzdiagramm\n",
    "fig, ax = plt.subplots(figsize=(10, 5))\n",
    "colors = [\"#D62728\" if d < 0 else \"#2CA02C\" for d in differenzen]\n",
    "\n",
    "ax.barh(krankheiten, differenzen, color=colors)\n",
    "ax.axvline(0, color='black', linewidth=0.8)  # Nulllinie fÃ¼r Vergleich\n",
    "ax.set_xlabel(\"Differenz im Ã˜ Zuckerkonsum (g/Tag)\")\n",
    "ax.set_title(\"Unterschied im Zuckerkonsum: Personen mit vs. ohne Krankheit\")\n",
    "ax.grid(axis='x', linestyle='--', alpha=0.5)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# =====================================================================\n",
    "# KAQ 1: Welche ErnÃ¤hrungsmuster lassen sich aus individuellen MakronÃ¤hrstoffprofilen ableiten â€“\n",
    "# und welche Krankheitsrisiken sind damit verbunden?\n",
    "# =====================================================================\n",
    "\n",
    "# ======================================================\n",
    "# Schritt 1: Auswahl der relevanten MakronÃ¤hrstoff-Features\n",
    "# ======================================================\n",
    "\n",
    "# Ziel: Auswahl der Variablen, die das tÃ¤gliche MakronÃ¤hrstoffprofil pro Person abbilden.\n",
    "# Diese dienen als Basis fÃ¼r das Clustering, um Muster zu erkennen.\n",
    "\n",
    "makro_features = [\n",
    "    \"Calories\",\n",
    "    \"Protein\",\n",
    "    \"Fat\",\n",
    "    \"Carbohydrates\",\n",
    "    \"Sugar\",\n",
    "    \"Fiber\",\n",
    "    \"Sodium\"\n",
    "]\n",
    "\n",
    "df_makros = df_meals[makro_features].copy()\n",
    "df_makros.head()\n",
    "\n",
    "# ======================================================\n",
    "# Schritt 2: Normalisierung der Daten (StandardScaler)\n",
    "# ======================================================\n",
    "\n",
    "# BegrÃ¼ndung: Da die Wertebereiche stark variieren (z.â€¯B. Kalorien vs. Zucker),\n",
    "# werden die Daten z-standardisiert, um gleichberechtigte Gewichtung sicherzustellen.\n",
    "\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "scaler = StandardScaler()\n",
    "df_makros_scaled = scaler.fit_transform(df_makros)\n",
    "df_makros_scaled = pd.DataFrame(df_makros_scaled, columns=makro_features)\n",
    "df_makros_scaled.head()\n",
    "\n",
    "# ======================================================\n",
    "# Schritt 3: Clustering mit K-Means\n",
    "# ======================================================\n",
    "\n",
    "# Ziel: Personen mit Ã¤hnlichem MakronÃ¤hrstoffprofil gruppieren.\n",
    "# Dies dient zur Identifikation typischer ErnÃ¤hrungsmuster (z.â€¯B. High-Protein-Cluster etc.).\n",
    "\n",
    "from sklearn.cluster import KMeans\n",
    "\n",
    "# Anzahl Cluster (z.â€¯B. 4 â€“ kann spÃ¤ter optimiert werden)\n",
    "k = 4\n",
    "kmeans = KMeans(n_clusters=k, random_state=42)\n",
    "clusters = kmeans.fit_predict(df_makros_scaled)\n",
    "\n",
    "# Cluster dem Original-Datensatz zuweisen\n",
    "df_meals[\"Cluster\"] = clusters\n",
    "\n",
    "# ======================================================\n",
    "# Schritt 4: Beschreibung der Cluster (ErnÃ¤hrungsmuster)\n",
    "# ======================================================\n",
    "\n",
    "# Ziel: Jedes Cluster interpretieren â€“ was zeichnet es aus?\n",
    "# Wir berechnen pro Cluster den Mittelwert der MakronÃ¤hrstoffe.\n",
    "\n",
    "df_cluster_profiles = df_meals.groupby(\"Cluster\")[makro_features].mean().round(1)\n",
    "display(df_cluster_profiles)\n",
    "\n",
    "# ======================================================\n",
    "# Schritt 5: Visualisierung der Clusterprofile\n",
    "# ======================================================\n",
    "\n",
    "# Ziel: Unterschiede der Cluster auf einen Blick erkennen.\n",
    "# Darstellung als gruppiertes Balkendiagramm.\n",
    "\n",
    "df_cluster_profiles.T.plot(kind='bar', figsize=(12, 6))\n",
    "plt.title(\"MakronÃ¤hrstoffprofil je Cluster\")\n",
    "plt.ylabel(\"TÃ¤gliche Durchschnittsmenge\")\n",
    "plt.xlabel(\"MakronÃ¤hrstoff\")\n",
    "plt.legend(title=\"Cluster\")\n",
    "plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.5)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# ======================================================\n",
    "# Schritt 6: Verbindung zu Krankheiten untersuchen\n",
    "# ======================================================\n",
    "\n",
    "# Ziel: Verteilung der Krankheiten je Cluster prÃ¼fen â€“ z.â€¯B. tritt Ãœbergewicht hÃ¤ufiger in Cluster 2 auf?\n",
    "\n",
    "df_cluster_disease = df_meals.groupby(\"Cluster\")[\"Disease_Count\"].mean().round(2)\n",
    "display(df_cluster_disease)\n",
    "\n",
    "# Optional: ClustergrÃ¶ÃŸen\n",
    "df_meals[\"Cluster\"].value_counts().sort_index()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# =====================================================================\n",
    "# KAQ 1: Welche ErnÃ¤hrungsmuster lassen sich aus individuellen MakronÃ¤hrstoffprofilen ableiten â€“\n",
    "# und welche Krankheitsrisiken sind damit verbunden?\n",
    "# =====================================================================\n",
    "\n",
    "# Berechnung der Mittelwerte der MakronÃ¤hrstoffe pro Cluster\n",
    "# cluster_means = df_meals.groupby(\"Cluster\")[makro_features].mean()\n",
    "\n",
    "# Mapping der Cluster zu benutzerdefinierten Namen\n",
    "cluster_labels = {\n",
    "    0: \"ErnÃ¤hrungsmuster 1\",\n",
    "    1: \"ErnÃ¤hrungsmuster 2\",\n",
    "    2: \"ErnÃ¤hrungsmuster 3\",\n",
    "    3: \"ErnÃ¤hrungsmuster 4\"\n",
    "}\n",
    "\n",
    "# Farbdefinition wie zuvor (fÃ¼r Konsistenz)\n",
    "colors = {\n",
    "    0: \"#1f77b4\",  # Blau\n",
    "    1: \"#ff7f0e\",  # Orange\n",
    "    2: \"#2ca02c\",  # GrÃ¼n\n",
    "    3: \"#d62728\"   # Rot\n",
    "}\n",
    "\n",
    "# Balkenzeichnung pro Cluster\n",
    "fig, ax = plt.subplots(figsize=(12, 6))\n",
    "width = 0.2\n",
    "x = np.arange(len(cluster_means.columns))\n",
    "\n",
    "for i, (cluster, row) in enumerate(cluster_means.iterrows()):\n",
    "    ax.bar(x + i * width,\n",
    "           row.values,\n",
    "           width=width,\n",
    "           label=cluster_labels[cluster],\n",
    "           color=colors[cluster])\n",
    "\n",
    "ax.set_xticks(x + width * 1.5)\n",
    "ax.set_xticklabels(cluster_means.columns)\n",
    "ax.set_ylabel(\"TÃ¤gliche Durchschnittsmenge\")\n",
    "ax.set_xlabel(\"MakronÃ¤hrstoff\")\n",
    "ax.set_title(\"MakronÃ¤hrstoffprofil je ErnÃ¤hrungsmuster\")\n",
    "ax.legend(title=\"Cluster\")\n",
    "ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.5)\n",
    "plt.tight_layout()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# =====================================================================\n",
    "# Mappen der ErnÃ¤hrungsmuster zu den Krankheiten\n",
    "# ========================================================\n",
    "# Mapping Cluster-Nummern zu ErnÃ¤hrungsmuster-Namen\n",
    "cluster_labels = {\n",
    "    0: \"ErnÃ¤hrungsmuster 1\",\n",
    "    1: \"ErnÃ¤hrungsmuster 2\",\n",
    "    2: \"ErnÃ¤hrungsmuster 3\",\n",
    "    3: \"ErnÃ¤hrungsmuster 4\"\n",
    "}\n",
    "\n",
    "farben = {\n",
    "    \"ErnÃ¤hrungsmuster 1\": \"#1f77b4\",\n",
    "    \"ErnÃ¤hrungsmuster 2\": \"#ff7f0e\",\n",
    "    \"ErnÃ¤hrungsmuster 3\": \"#2ca02c\",\n",
    "    \"ErnÃ¤hrungsmuster 4\": \"#d62728\"\n",
    "}\n",
    "\n",
    "# Cluster-Nummern in sprechende Bezeichnungen umwandeln\n",
    "df_meals[\"ErnÃ¤hrungsmuster\"] = df_meals[\"Cluster\"].map(cluster_labels)\n",
    "\n",
    "# Explodiere Disease-Listen (eine Zeile pro Krankheit)\n",
    "df_disease_split = df_meals.explode(\"Disease_List\")\n",
    "\n",
    "# Berechne HÃ¤ufigkeit pro ErnÃ¤hrungsmuster und Krankheit\n",
    "df_disease_counts = df_disease_split.groupby([\"ErnÃ¤hrungsmuster\", \"Disease_List\"]).size().unstack(fill_value=0)\n",
    "\n",
    "# Sortiere Krankheiten nach GesamthÃ¤ufigkeit\n",
    "df_disease_counts = df_disease_counts[df_disease_counts.sum().sort_values(ascending=False).index]\n",
    "\n",
    "# Plot\n",
    "df_disease_counts.T.plot(kind=\"bar\", figsize=(14, 6), color=[farben[label] for label in df_disease_counts.index])\n",
    "\n",
    "plt.title(\"HÃ¤ufigkeit ernÃ¤hrungsbedingter Krankheiten je ErnÃ¤hrungsmuster\")\n",
    "plt.xlabel(\"Krankheit\")\n",
    "plt.ylabel(\"Anzahl Personen\")\n",
    "plt.legend(title=\"ErnÃ¤hrungsmuster\")\n",
    "plt.xticks(rotation=45, ha=\"right\")\n",
    "plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.5)\n",
    "plt.tight_layout()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.patches import Patch\n",
    "\n",
    "# Farben pro ErnÃ¤hrungsmuster\n",
    "farben = {\n",
    "    0: \"#1f77b4\",  # Blau\n",
    "    1: \"#ff7f0e\",  # Orange\n",
    "    2: \"#2ca02c\",  # GrÃ¼n\n",
    "    3: \"#d62728\",  # Rot\n",
    "}\n",
    "\n",
    "# Mapping ErnÃ¤hrungsmuster fÃ¼r Legende\n",
    "legend_labels = {\n",
    "    0: \"ErnÃ¤hrungsmuster 1\",\n",
    "    1: \"ErnÃ¤hrungsmuster 2\",\n",
    "    2: \"ErnÃ¤hrungsmuster 3\",\n",
    "    3: \"ErnÃ¤hrungsmuster 4\"\n",
    "}\n",
    "\n",
    "# Liste aller Krankheiten\n",
    "alle_krankheiten = df_meals[\"Disease_List\"].explode().dropna().unique()\n",
    "\n",
    "# Layout\n",
    "n = len(alle_krankheiten)\n",
    "cols = 3\n",
    "rows = (n + cols - 1) // cols\n",
    "\n",
    "fig, axes = plt.subplots(rows, cols, figsize=(15, 4 * rows))\n",
    "axes = axes.flatten()\n",
    "\n",
    "for i, krankheit in enumerate(alle_krankheiten):\n",
    "    ax = axes[i]\n",
    "\n",
    "    # Personen mit dieser Krankheit\n",
    "    maske = df_meals[\"Disease_List\"].apply(lambda x: krankheit in x)\n",
    "    df_krank = df_meals[maske]\n",
    "\n",
    "    # Cluster-Anteile berechnen\n",
    "    cluster_counts = df_krank[\"Cluster\"].value_counts().sort_index()\n",
    "    labels = [str(i + 1) for i in cluster_counts.index]  # Beschriftung: 1, 2, 3, 4\n",
    "    colors = [farben[i] for i in cluster_counts.index]\n",
    "\n",
    "    # Kreisdiagramm\n",
    "    ax.pie(cluster_counts, labels=labels, colors=colors, autopct=\"%1.1f%%\", startangle=90)\n",
    "    ax.set_title(f\"{krankheit} (n={cluster_counts.sum()})\", fontsize=12)\n",
    "\n",
    "# Leere Subplots ausblenden\n",
    "for j in range(i + 1, len(axes)):\n",
    "    fig.delaxes(axes[j])\n",
    "\n",
    "# Legende oben rechts einfÃ¼gen\n",
    "legende = [Patch(color=farben[i], label=legend_labels[i]) for i in range(4)]\n",
    "fig.legend(handles=legende, title=\"ErnÃ¤hrungsmuster\", loc=\"upper right\", fontsize=10)\n",
    "\n",
    "plt.suptitle(\"Verteilung der ErnÃ¤hrungsmuster pro Krankheit\", fontsize=16)\n",
    "plt.tight_layout()\n",
    "plt.subplots_adjust(top=0.9, right=0.85)\n",
    "plt.show()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
